//// Created by Ben Gotts on 07/07/2025.//#include "VoxelChunk.h"#include <future>#include <glm/vec3.hpp>#include <spdlog/spdlog.h>#include "src/Core/Mesh.h"#include "random"#include "VoxelTerrainGenerator.h"#include "VoxelWorld.h"#include "src/Physics/Physics.h"VoxelChunk::VoxelChunk() : ChunkSpriteSheet("../assets/textures/VoxelTextures.png", "diffuse", 0), _chunkMesh(nullptr) {    _boundingBox = new BoundingBox();}VoxelChunk::~VoxelChunk() {    delete _boundingBox;}void VoxelChunk::Setup(ChunkTerrainData terrainData) {    _blocks.resize(CHUNK_SIZE);    for (int x = 0; x < CHUNK_SIZE; ++x) {        _blocks[x].resize(CHUNK_SIZE);        for (int y = 0; y < CHUNK_SIZE; ++y) {            _blocks[x][y].resize(CHUNK_SIZE);            for (int z = 0; z < CHUNK_SIZE; ++z) {                _blocks[x][y][z] = std::make_unique<VoxelBlock>(BLOCK_TYPE_STONE);            }        }    }    for (int x = 0; x < CHUNK_SIZE; ++x) {        for (int y = 0; y < CHUNK_SIZE; ++y) {            for (int z = 0; z < CHUNK_SIZE; ++z) {                _blocks[x][y][z].get()->SetActive(terrainData.Blocks[x][y][z]->IsActive());                _blocks[x][y][z].get()->SetBlockType(terrainData.Blocks[x][y][z]->GetBlockType());            }        }    }    _isSetup = true;}void VoxelChunk::Update(float deltaTime) {    if (_isLoadingChunk && _futureMeshData.valid()) {        auto status = _futureMeshData.wait_for(std::chrono::milliseconds(0));        if (status == std::future_status::ready) {            auto data = _futureMeshData.get();            _meshVertices = data.MeshVertices;            _meshIndices = data.MeshIndices;            CreateMesh();            _hasLoadedChunkMesh = true;            _isLoadingChunk = false;        }    }    if (!IsLoaded())        return;    _chunkMesh->Position = _worldPosition.Position;    if (_chunkMesh->Position != _worldPosition.Position) {        RecalculateBounds();    }    _isEmpty = _chunkMesh->GetNumVerts() == 0 && _chunkMesh->GetNumIndices() == 0;}void VoxelChunk::Load() {    if (_hasLoadedChunk || _isLoadingChunk)        return;    _isLoadingChunk = true;    _futureMeshData = VoxelWorld::ChunkPool.submit_task([this]() -> MeshData {        MeshData meshData{_meshVertices, _meshIndices, _meshTextures};        CreateMeshData(meshData);        _hasLoadedChunk = true;        return meshData;    });    spdlog::info("Loading Chunk: {0},{1}", _worldPosition.Position.x, _worldPosition.Position.z);}void VoxelChunk::Unload() {    if (!_hasLoadedChunk) {        spdlog::warn("Trying to unload chunk that isn't loaded");        return;    }    _hasLoadedChunk = false;    spdlog::info("Unloading Chunk: {0},{1}", _worldPosition.Position.x, _worldPosition.Position.z);}void VoxelChunk::ForceRebuild() {    _hasLoadedChunk = false;    _hasLoadedChunkMesh = false;    _isLoadingChunk = true;    MeshData meshData{_meshVertices, _meshIndices, _meshTextures};    CreateMeshData(meshData);    _meshVertices = meshData.MeshVertices;    _meshIndices = meshData.MeshIndices;    CreateMesh();    _hasLoadedChunk = true;    _hasLoadedChunkMesh = true;}void VoxelChunk::Render(Shader& shader, Camera& camera) {    if (!IsLoaded())        return;    shader.SetFloat("scale", VOXEL_SIZE);    _chunkMesh->Draw(shader, camera);}bool VoxelChunk::ShouldRender() {    return !_isEmpty && _hasLoadedChunk;}void VoxelChunk::CreateVoxel(glm::vec3 position, VoxelBlockTextureData textureData, NeighbourStates neighbourStates, MeshData& outMeshData) {    Vertex vertices[24];    GLuint vertexOffset = static_cast<GLuint>(outMeshData.MeshVertices.size());    std::vector<GLuint> offsetIndices;    // Front face (zNeg)    GLuint frontIndices[] = { 0, 3, 2, 2, 1, 0 };    // Back face (zPos)    GLuint backIndices[] = { 4, 5, 6, 6, 7, 4 };    // Left face (xNeg)    GLuint leftIndices[] = { 11, 8, 9, 9, 10, 11 };    // Right face (xPos)    GLuint rightIndices[] = { 12, 13, 14, 14, 15, 12 };    // Bottom face (yNeg)    GLuint bottomIndices[] = { 16, 17, 18, 18, 19, 16 };    // Top face (yPos)    GLuint topIndices[] = { 20, 21, 22, 22, 23, 20 };    glm::vec3 colour = {1.0f, 1.0f, 1.0f};    bool hasTopFace = textureData.TopCoords != glm::vec2(-1, -1);    bool hasBottomFace = textureData.BottomCoords != glm::vec2(-1, -1);    constexpr float sheetWidth = 1280.0f;    constexpr float sheetHeight = 1280.0f;    constexpr float spriteWidth = 128.0f;    constexpr float spriteHeight = 128.0f;    glm::vec2 sideTextureCoords[]{        {(textureData.SideCoords.x * spriteWidth) / sheetWidth, (textureData.SideCoords.y * spriteHeight) / sheetHeight},        {((textureData.SideCoords.x + 1) * spriteWidth) / sheetWidth, (textureData.SideCoords.y * spriteHeight) / sheetHeight},        {((textureData.SideCoords.x + 1) * spriteWidth) / sheetWidth, ((textureData.SideCoords.y + 1) * spriteHeight) / sheetHeight},        {(textureData.SideCoords.x * spriteWidth) / sheetWidth, ((textureData.SideCoords.y + 1) * spriteHeight) / sheetHeight}    };    glm::vec2 topTextureCoords[]{        {(textureData.TopCoords.x * spriteWidth) / sheetWidth, (textureData.TopCoords.y * spriteHeight) / sheetHeight},        {((textureData.TopCoords.x + 1) * spriteWidth) / sheetWidth, (textureData.TopCoords.y * spriteHeight) / sheetHeight},        {((textureData.TopCoords.x + 1) * spriteWidth) / sheetWidth, ((textureData.TopCoords.y + 1) * spriteHeight) / sheetHeight},        {(textureData.TopCoords.x * spriteWidth) / sheetWidth, ((textureData.TopCoords.y + 1) * spriteHeight) / sheetHeight}    };    glm::vec2 bottomTextureCoords[]{        {(textureData.BottomCoords.x * spriteWidth) / sheetWidth, (textureData.BottomCoords.y * spriteHeight) / sheetHeight},        {((textureData.BottomCoords.x + 1) * spriteWidth) / sheetWidth, (textureData.BottomCoords.y * spriteHeight) / sheetHeight},        {((textureData.BottomCoords.x + 1) * spriteWidth) / sheetWidth, ((textureData.BottomCoords.y + 1) * spriteHeight) / sheetHeight},        {(textureData.BottomCoords.x * spriteWidth) / sheetWidth, ((textureData.BottomCoords.y + 1) * spriteHeight) / sheetHeight}    };    // Front face (zNeg)    if (neighbourStates.zNeg == true) {        glm::vec3 normal = glm::vec3(0.0f, 0.0f, -1.0f);        vertices[0] = Vertex({{-0.5f, -0.5f, -0.5f}, colour, sideTextureCoords[0], normal});        vertices[1] = Vertex({{ 0.5f, -0.5f, -0.5f}, colour, sideTextureCoords[1], normal});        vertices[2] = Vertex({{ 0.5f,  0.5f, -0.5f}, colour, sideTextureCoords[2], normal});        vertices[3] = Vertex({{-0.5f,  0.5f, -0.5f}, colour, sideTextureCoords[3], normal});        for (auto idx : frontIndices)            offsetIndices.push_back(idx + vertexOffset);    }    // Back face (zPos)    if (neighbourStates.zPos == true) {        glm::vec3 normal = glm::vec3(0.0f, 0.0f, 1.0f);        vertices[4] = Vertex({{-0.5f, -0.5f,  0.5f}, colour, sideTextureCoords[1], normal});        vertices[5] = Vertex({{ 0.5f, -0.5f,  0.5f}, colour, sideTextureCoords[0], normal});        vertices[6] = Vertex({{ 0.5f,  0.5f,  0.5f}, colour, sideTextureCoords[3], normal});        vertices[7] = Vertex({{-0.5f,  0.5f,  0.5f}, colour, sideTextureCoords[2], normal});        for (auto idx : backIndices)            offsetIndices.push_back(idx + vertexOffset);    }    // Left face (xNeg)    if (neighbourStates.xNeg == true) {        glm::vec3 normal = glm::vec3(-1.0f, 0.0f, 0.0f);        vertices[8]  = Vertex({{-0.5f,  0.5f, -0.5f}, colour, sideTextureCoords[3], normal});        vertices[9]  = Vertex({{-0.5f, -0.5f, -0.5f}, colour, sideTextureCoords[0], normal});        vertices[10] = Vertex({{-0.5f, -0.5f,  0.5f}, colour, sideTextureCoords[1], normal});        vertices[11] = Vertex({{-0.5f,  0.5f,  0.5f}, colour, sideTextureCoords[2], normal});        for (auto idx : leftIndices)            offsetIndices.push_back(idx + vertexOffset);    }    // Right face (xPos)    if (neighbourStates.xPos == true) {        glm::vec3 normal = glm::vec3(1.0f, 0.0f, 0.0f);        vertices[12] = Vertex({{ 0.5f, -0.5f, -0.5f}, colour, sideTextureCoords[0], normal});        vertices[13] = Vertex({{ 0.5f,  0.5f, -0.5f}, colour, sideTextureCoords[3], normal});        vertices[14] = Vertex({{ 0.5f,  0.5f,  0.5f}, colour, sideTextureCoords[2], normal});        vertices[15] = Vertex({{ 0.5f, -0.5f,  0.5f}, colour, sideTextureCoords[1], normal});        for (auto idx : rightIndices)            offsetIndices.push_back(idx + vertexOffset);    }    // Bottom face (yNeg)    if (neighbourStates.yNeg == true) {        glm::vec3 normal = glm::vec3(0.0f, -1.0f, 0.0f);        if (hasBottomFace) {            vertices[16] = Vertex({{-0.5f, -0.5f, -0.5f}, colour, bottomTextureCoords[0], normal});            vertices[17] = Vertex({{ 0.5f, -0.5f, -0.5f}, colour, bottomTextureCoords[1], normal});            vertices[18] = Vertex({{ 0.5f, -0.5f,  0.5f}, colour, bottomTextureCoords[2], normal});            vertices[19] = Vertex({{-0.5f, -0.5f,  0.5f}, colour, bottomTextureCoords[3], normal});        }        else {            vertices[16] = Vertex({{-0.5f, -0.5f, -0.5f}, colour, sideTextureCoords[0], normal});            vertices[17] = Vertex({{ 0.5f, -0.5f, -0.5f}, colour, sideTextureCoords[1], normal});            vertices[18] = Vertex({{ 0.5f, -0.5f,  0.5f}, colour, sideTextureCoords[2], normal});            vertices[19] = Vertex({{-0.5f, -0.5f,  0.5f}, colour, sideTextureCoords[3], normal});        }        for (auto idx : bottomIndices)            offsetIndices.push_back(idx + vertexOffset);    }    // Top face (yPos)    if (neighbourStates.yPos == true) {        glm::vec3 normal = glm::vec3(0.0f, 1.0f, 0.0f);        if (hasTopFace) {            vertices[20] = Vertex({{ 0.5f,  0.5f, -0.5f}, colour, topTextureCoords[0], normal});            vertices[21] = Vertex({{-0.5f,  0.5f, -0.5f}, colour, topTextureCoords[1], normal});            vertices[22] = Vertex({{-0.5f,  0.5f,  0.5f}, colour, topTextureCoords[2], normal});            vertices[23] = Vertex({{ 0.5f,  0.5f,  0.5f}, colour, topTextureCoords[3], normal});        }        else {            vertices[20] = Vertex({{ 0.5f,  0.5f, -0.5f}, colour, sideTextureCoords[0], normal});            vertices[21] = Vertex({{-0.5f,  0.5f, -0.5f}, colour, sideTextureCoords[1], normal});            vertices[22] = Vertex({{-0.5f,  0.5f,  0.5f}, colour, sideTextureCoords[2], normal});            vertices[23] = Vertex({{ 0.5f,  0.5f,  0.5f}, colour, sideTextureCoords[3], normal});        }        for (auto idx : topIndices)            offsetIndices.push_back(idx + vertexOffset);    }    for (auto& v : vertices)        v.position += position;    outMeshData.MeshVertices.insert(outMeshData.MeshVertices.end(), std::begin(vertices), std::end(vertices));    outMeshData.MeshIndices.insert(outMeshData.MeshIndices.end(), offsetIndices.begin(), offsetIndices.end());}void VoxelChunk::CreateMeshData(MeshData& outMeshData) {    outMeshData.MeshVertices.clear();    outMeshData.MeshIndices.clear();    outMeshData.MeshTextures.clear();    for (int x = 0; x < CHUNK_SIZE; ++x) {        for (int y = 0; y < CHUNK_SIZE; ++y) {            for (int z = 0; z < CHUNK_SIZE; ++z) {                if (_blocks[x][y][z]->IsActive() == false)                    continue;                bool xNegative = true;                bool xPositive = true;                bool yNegative = true;                bool yPositive = true;                bool zNegative = true;                bool zPositive = true;                if (x > 0)                    xNegative = !_blocks[x - 1][y][z]->IsActive();                if (x < CHUNK_SIZE - 1)                    xPositive = !_blocks[x + 1][y][z]->IsActive();                if (y > 0)                    yNegative = !_blocks[x][y - 1][z]->IsActive();                if (y < CHUNK_SIZE - 1)                    yPositive = !_blocks[x][y + 1][z]->IsActive();                if (z > 0)                    zNegative = !_blocks[x][y][z - 1]->IsActive();                if (z < CHUNK_SIZE - 1)                    zPositive = !_blocks[x][y][z + 1]->IsActive();                NeighbourStates neighbourStates = {xNegative, xPositive, yNegative,                    yPositive, zNegative, zPositive};                CreateVoxel(glm::vec3(x,y,z), _blocks[x][y][z]->GetBlockTextureCoords(), neighbourStates, outMeshData);            }        }    }}void VoxelChunk::CreateMesh() {    _meshTextures.emplace_back(ChunkSpriteSheet);    _chunkMesh = std::make_unique<Mesh>(_meshVertices, _meshIndices, _meshTextures);}void VoxelChunk::RecalculateBounds() {    glm::vec3 chunkWorldPos = _worldPosition.Position + glm::vec3(    CHUNK_SIZE * VOXEL_SIZE,    CHUNK_SIZE * VOXEL_SIZE,    CHUNK_SIZE * VOXEL_SIZE);    glm::vec3 boundsMin = chunkWorldPos;    glm::vec3 boundsMax = chunkWorldPos + glm::vec3(CHUNK_SIZE * VOXEL_SIZE, CHUNK_SIZE * VOXEL_SIZE, CHUNK_SIZE * VOXEL_SIZE);    _boundingBox = new BoundingBox(boundsMin, boundsMax);}BoundingBox* VoxelChunk::GetBounds() {    return _boundingBox;}VoxelBlock* VoxelChunk::GetVoxelBlock(WorldPosition worldPosition) {    LocalVoxelPosition localVoxelPosition = WorldPositionToLocalVoxel(worldPosition);    return GetVoxelBlock(localVoxelPosition);}VoxelBlock* VoxelChunk::GetVoxelBlock(LocalVoxelPosition localVoxelPosition) {    glm::ivec3 pos = localVoxelPosition.Position;    if (pos.x >= 0 && pos.y >= 0 && pos.z >= 0 &&        pos.x < CHUNK_SIZE && pos.y < CHUNK_SIZE && pos.z < CHUNK_SIZE)        return _blocks[pos.x][pos.y][pos.z].get();    return nullptr;}VoxelBlock* VoxelChunk::GetVoxelBlock(LocalVoxelPosition localVoxelPosition, LocalVoxelPosition& voxelBlockPosition) {    glm::ivec3 pos = localVoxelPosition.Position;    if (pos.x >= 0 && pos.y >= 0 && pos.z >= 0 &&        pos.x < CHUNK_SIZE && pos.y < CHUNK_SIZE && pos.z < CHUNK_SIZE) {        voxelBlockPosition = {glm::ivec3(pos.x, pos.y, pos.z)};        return _blocks[pos.x][pos.y][pos.z].get();    }    return nullptr;}bool VoxelChunk::IsLoaded() {    return _hasLoadedChunk;}bool VoxelChunk::IsSetup() {    return _isSetup;}WorldPosition VoxelChunk::GetWorldPosition() {    return _worldPosition;}void VoxelChunk::SetWorldPosition(WorldPosition val) {    _worldPosition = val;}ChunkPosition VoxelChunk::GetChunkPosition() {    _chunkPosition = WorldPositionToChunk(_worldPosition);    return _chunkPosition;}